#coding=utf-8

import Crypto
from Crypto import Random
from Crypto.Hash import SHA, SHA256
from Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5
from Crypto.Signature import PKCS1_v1_5 as Signature_pkcs1_v1_5
from Crypto.PublicKey import RSA
import base64,random,os
from Crypto.Cipher import PKCS1_OAEP,AES
import socket
import cPickle
import hashlib
import time
import sys
reload(sys)
sys.setdefaultencoding("utf8")


IP_TARGET="192.168.0.113"

def apply_sha256(pw):
	m = hashlib.sha256()
	m.update(pw)
	return m.hexdigest()


"""
# 伪随机数生成器
random_generator = Random.new().read
# rsa算法生成实例
rsa = RSA.generate(1024, random_generator)

# master的秘钥对的生成
private_pem = rsa.exportKey()

with open('AdminMasterPrivKey.pem', 'w') as f:
    f.write(private_pem)

public_pem = rsa.publickey().exportKey()
with open('AdminMasterPubKey.pem', 'w') as f:
    f.write(public_pem)


random_generator = Random.new().read
rsa = RSA.generate(1024, random_generator)

# ghost的秘钥对的生成
private_pem = rsa.exportKey()
with open('THMasterPrivKey.pem', 'w') as f:
    f.write(private_pem)

public_pem = rsa.publickey().exportKey()
with open('THMasterPubKey.pem', 'w') as f:
    f.write(public_pem)
"""
##################################################################
"""
Admin sends a request to target hardware for a current public key, 
this request contains nonce generated by admin and it is signed with AdminMasterPrivKey 
and then encrypted using THMasterPubKey (1)
"""

def generate_nonce(length=16):
    """Generate pseudorandom number."""
    return ''.join([str(random.randint(0, 9)) for i in range(length)])

#print(generate_nonce())
#AdminMasterPrivKey= RSA.importKey(open("AdminMasterPrivKey.pem").read())#.exportKey()
AdminMasterPrivKey="-----BEGIN RSA PRIVATE KEY-----\n\
MIICXQIBAAKBgQDScydKll9d21yb8H0JEwaV96j/iNUp0iTgZkxPnKXEv/1xs5Ua\n\
hKWMwB5qH3YHkxAbhpPMzmDE2xzT8eal8NIfzwKAnk3a+EYUm6Qp8CBoOOV3pyxU\n\
o/yqsV1hvZo7B73qiwR3/8zQQlVrL+Dlrfu7Dyi2Reasm+rEPhbqc9XMWQIDAQAB\n\
AoGBAJSfRFFVjvYOtAFgvjzJVe5VH+GO9dN6GBbtx9i1bRBc8hT5WUSIBw42o4QY\n\
wdcpkceOrBSIbyi3AU3g2R25y/novNcSCSrZiPs+JUbgIUJQEd5/KdlbOdEgyQBd\n\
HgUI3Ch0veqmObL1pTPFVLF+BX33F9AXJdoSKxysCalcVTCxAkEA38Hq80BL8mu5\n\
m6vTmtbHUii1/cgOLxQGanAtFTzaEHXZA/t1BzyPUFDTtYO6rEsQcP1Rk2b//6Me\n\
Yl3qDPoadQJBAPDGVdsEozPI7YxLH1b++iaYCY5PIGmps0p4qxMBAzrEOENQlqtj\n\
8qZF38BGjUwia8TtgmfOTe7ZM7XX3nIjhdUCQQC2Lr2NsRwlFXDaPtzbhWRkkKEd\n\
MHXb/wH6R7ttP06NeGZpx6NRcQ1+51B4yfiDr9qDJL32tjZZfgaPMMgQKNLBAkBB\n\
mchKpDjTIyuVzeH8EfyWB1aTL3vlThdLcxUpWF1I5a1uqcZjbBfwtZkBCjf1RmuW\n\
fB/LqKoTKZqtMOOqtYMBAkAODbylP9eL1LvJLe2w3XEHyIGde4najx/gMVNQHtWP\n\
Kd8LpzgSHuMb/6zF+Bs1N3kP6xcCTIfaELIIwbwuQbLo\n\
-----END RSA PRIVATE KEY-----"
#AdminMasterPubKey= RSA.importKey(open("AdminMasterPubKey.pem").read())#.exportKey()
AdminMasterPubKey="-----BEGIN PUBLIC KEY-----\n\
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDScydKll9d21yb8H0JEwaV96j/\n\
iNUp0iTgZkxPnKXEv/1xs5UahKWMwB5qH3YHkxAbhpPMzmDE2xzT8eal8NIfzwKA\n\
nk3a+EYUm6Qp8CBoOOV3pyxUo/yqsV1hvZo7B73qiwR3/8zQQlVrL+Dlrfu7Dyi2\n\
Reasm+rEPhbqc9XMWQIDAQAB\n\
-----END PUBLIC KEY-----"
#nonce="5811971567083307"
nonce=generate_nonce()
print "nonce1 generated", nonce
#with open("AdminMasterPrivKey.pem") as f:#sign encrypted using AdminMasterPrivKey
 #   key=f.read()
rsakey = RSA.importKey(AdminMasterPrivKey)
signer = Signature_pkcs1_v1_5.new(rsakey)
digest = SHA.new()
digest.update(nonce)
sign = signer.sign(digest)
signature = base64.b64encode(sign)
 #   f.close()

#with open('THMasterPubKey.pem') as f:# and then encrypted using THMasterPubKey
THMasterPubKey="-----BEGIN PUBLIC KEY-----\n\
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDckTwX2dc3JWFJmePbd01ymnh\n\
b4U4oEMDfDd/c+dvoaTrzCVXIInnp4OEjMFjaodFAmb2X6WfJbfzZxKhrzvg44nm\n\
C4ilGwaK6DG/cJ9peV+t7plOHC6bSOj4TK4JaejCh7yjT4FHypJPxw4njCgC/FIW\n\
tebkB4vLCvNZOWZkAwIDAQAB\n\
-----END PUBLIC KEY-----"
#    key = f.read()
rsakey = RSA.importKey(THMasterPubKey)
THMasterPubKey=rsakey
cipher = Cipher_pkcs1_v1_5.new(rsakey)
cipher_text = base64.b64encode(cipher.encrypt(nonce))
 #   f.close()

#print (cipher_text)

client = socket.socket()
ip_port=(IP_TARGET,10086)
print("socket connecting...")
client.connect(ip_port)
print(nonce)
print(signature)
print(cipher_text)
client.send(nonce)
client.send(signature)
client.send(cipher_text)# pair 1
print("socket data1 sent successfully...")

"""
Upon receiving a request, 
target hardware decrypts it using THMasterPrivKey and verifies message authenticity by verifying digital signature 
with AdminMasterPubKey, which was stored locally (2). 
"""

"""Target hardware generates current key pair (THCurrentPrivKey and THCurrentPubKey) and stores them locally, then it signs THCurrentPubKey and nonce received from admin using THMasterPrivKey, and then encrypts it with AdminMasterPubKey. This message is sent to the administrator (3). 
Admin decrypts received message with AdminMasterPrivKey and verifies message authenticity by decrypting digital signature 
with THMasterPubKey. THCurrentPublicKey is then stored locally on the admin (4). 
Then, admin generates current key pair (AdminCurrentPrivKey and AdminCurrentPubKey), 
signs AdminCurrentPubKey and nonce received from target hardware with AdminMasterPrivKey and encrypts it with THCurrentPubKey. This message is sent to the target hardware (5).
"""

print("waiting for socket data 2...")
#signature_THCurrentPubKey = client.recv(172)
#signature_nonce_received1 = client.recv(172)

fobj1=client.recv(332)
open("targethardware/ciphertext1signature_THCurrentPubKey", 'wb').write(fobj1)
fobj2=client.recv(332)
open("targethardware/ciphertext2signature_nonce_received1", 'wb').write(fobj2)
fobj3=client.recv(431)
open("targethardware/ciphertext3THCurrentPubKey", 'wb').write(fobj3)
nonce2_received=client.recv(16)
print("socket data 2 received...")
#print(fobj1)
#print(fobj2)
#print(fobj3)
print(nonce2_received)

db_name = 'nonce_.db'
db={}

try:
    with open(db_name, 'rb') as input_db:
        db = cPickle.load(input_db)
except IOError:
    pass

nonce2_received_hash=apply_sha256(nonce2_received)
print(nonce2_received_hash)
nonce_timestamp=time.time()
if nonce2_received_hash in db.keys():
    print "[Warning***] nonce2 exists at the time stamp: ", db[nonce2_received_hash]

db[nonce2_received_hash]=(nonce_timestamp)

with open(db_name, 'wb') as output_db:
    db = cPickle.dump(db,output_db)

#print(type(fobj1))
#AdminMasterPrivKey= RSA.importKey(open("AdminMasterPrivKey.pem").read())
with open("targethardware/ciphertext1signature_THCurrentPubKey", 'rb') as fobj:
  #  enc_session_key, NONCE, tag, ciphertext = [fobj.read(x) for x in (AdminMasterPrivKey.size_in_bytes(),  16, 16, -1)]
    enc_session_key=fobj.read(RSA.importKey(AdminMasterPrivKey).size_in_bytes())#enc_session_key=fobj1[0:RSA.importKey(AdminMasterPrivKey).size_in_bytes()]#enc_session_key=fobj.read(AdminMasterPrivKey.size_in_bytes())
    NONCE=fobj.read(16)#NONCE=fobj1[RSA.importKey(AdminMasterPrivKey).size_in_bytes():RSA.importKey(AdminMasterPrivKey).size_in_bytes()+16]#NONCE=fobj.read(16)
    tag=fobj.read(16)#tag=fobj1[RSA.importKey(AdminMasterPrivKey).size_in_bytes()+16:RSA.importKey(AdminMasterPrivKey).size_in_bytes()+32]#
    ciphertext =  fobj.read(-1)#ciphertext=fobj1[RSA.importKey(AdminMasterPrivKey).size_in_bytes()+32:-1]#
    cipher_rsa = PKCS1_OAEP.new( RSA.importKey(AdminMasterPrivKey))
 #   print(AdminMasterPrivKey.size_in_bytes(),enc_session_key,NONCE,tag,ciphertext)
    session_key = cipher_rsa.decrypt(enc_session_key)
    cipher_aes = AES.new(session_key, AES.MODE_EAX, NONCE)
    try:
        dataciphertext1signature_THCurrentPubKey = cipher_aes.decrypt_and_verify(ciphertext, tag)
    except Exception, e:
        print (repr(e))
    else:
        print("THCurrentPubKey signature MAC checked...")

    #print(dataciphertext1signature_THCurrentPubKey)
fobj.close()

with open("targethardware/ciphertext2signature_nonce_received1", 'rb') as fobj:
  #  enc_session_key, NONCE, tag, ciphertext = [fobj.read(x) for x in (AdminMasterPrivKey.size_in_bytes(),  16, 16, -1)]
    enc_session_key=fobj.read(RSA.importKey(AdminMasterPrivKey).size_in_bytes())
    NONCE=fobj.read(16)
    tag=fobj.read(16)
    ciphertext =  fobj.read(-1)
    cipher_rsa = PKCS1_OAEP.new( RSA.importKey(AdminMasterPrivKey))
  #  print(AdminMasterPrivKey.size_in_bytes(),enc_session_key,NONCE,tag,ciphertext)
    session_key = cipher_rsa.decrypt(enc_session_key)
    cipher_aes = AES.new(session_key, AES.MODE_EAX, NONCE)
    try:
        dataciphertext2signature_nonce_received1 = cipher_aes.decrypt_and_verify(ciphertext, tag)
    except Exception, e:
        print (repr(e))
    else:
        print("nonce_received1 signature MAC checked...")
    #print(dataciphertext2signature_nonce_received1)
fobj.close()

with open("targethardware/ciphertext3THCurrentPubKey", 'rb') as fobj:
  #  enc_session_key, NONCE, tag, ciphertext = [fobj.read(x) for x in (AdminMasterPrivKey.size_in_bytes(),  16, 16, -1)]
    enc_session_key=fobj.read(RSA.importKey(AdminMasterPrivKey).size_in_bytes())
    NONCE=fobj.read(16)
    tag=fobj.read(16)
    ciphertext =  fobj.read(-1)
    cipher_rsa = PKCS1_OAEP.new(RSA.importKey(AdminMasterPrivKey))
  #  print(AdminMasterPrivKey.size_in_bytes(),enc_session_key,NONCE,tag,ciphertext)
    session_key = cipher_rsa.decrypt(enc_session_key)
    cipher_aes = AES.new(session_key, AES.MODE_EAX, NONCE)
    try:
        dataTHCurrentPubKey = cipher_aes.decrypt_and_verify(ciphertext, tag)
    except Exception, e:
        print (repr(e))
    else:
        print("THCurrentPubKey MAC checked...")
        print(dataTHCurrentPubKey)
fobj.close()

#with open('THMasterPubKey.pem') as f:
#    key = f.read()
rsakey = THMasterPubKey
verifier = Signature_pkcs1_v1_5.new(rsakey)
digest = SHA.new()
    # Assumes the data is base64 encoded to begin with
digest.update(dataTHCurrentPubKey)
signer = Signature_pkcs1_v1_5.new(rsakey)
is_verify = signer.verify(digest, base64.b64decode(dataciphertext1signature_THCurrentPubKey))
#    f.close()
if is_verify== True:
    print "verify signature_THCurrentPubKey ", is_verify
else :
    print("[Warning***] signature_THCurrentPubKey is not verified...")



#with open('THMasterPubKey.pem') as f:
  #  key = f.read()
rsakey = THMasterPubKey
verifier = Signature_pkcs1_v1_5.new(rsakey)
digest = SHA.new()
    # Assumes the data is base64 encoded to begin with
digest.update(nonce)
signer = Signature_pkcs1_v1_5.new(rsakey)
is_verify = signer.verify(digest, base64.b64decode(dataciphertext2signature_nonce_received1))
 #   f.close()
if is_verify == True:
    print "verify signature_nonce_received1", is_verify
else:
    print("[Warning***] signature_nonce_received1 is not verified...")

#open("THCurrentPubKey.pem", 'w').write(dataTHCurrentPubKey)
THCurrentPubKey=dataTHCurrentPubKey

#admin generates current key pair (AdminCurrentPrivKey and AdminCurrentPubKey
###################
rsa = RSA.generate(1024)
private_pem = rsa.exportKey()
AdminCurrentPrivKey=private_pem
#with open('AdminCurrentPrivKey.pem', 'w') as f:
#    f.write(private_pem)
#    f.close()

public_pem = rsa.publickey().exportKey()
AdminCurrentPubKey=public_pem
#with open('AdminCurrentPubKey.pem', 'w') as f:
#    f.write(public_pem)
#    f.close()
print("AdminCurrentPrivKey and AdminCurrentPubKey generated...")
print(AdminCurrentPubKey)


#signs AdminCurrentPubKey and nonce received from target hardware (nonce2_received)  with AdminMasterPrivKey and encrypts it with THCurrentPubKey. This message is sent to the target hardware (5).
#nonce2_received="2380933129441206"#####
#AdminCurrentPrivKey=RSA.importKey(open("AdminCurrentPrivKey.pem").read())#.exportKey()
#AdminCurrentPubKey=RSA.importKey(open("AdminCurrentPubKey.pem").read())#.exportKey()
#with open("AdminMasterPrivKey.pem") as f:#signs AdminCurrentPubKey and nonce received from admin using AdminMasterPrivKey
 #   key=f.read()
rsakey = RSA.importKey(AdminMasterPrivKey)
signer = Signature_pkcs1_v1_5.new(rsakey)
digest = SHA.new()
digest.update(AdminCurrentPubKey)
sign = signer.sign(digest)
signature_TAdminCurrentPubKey = base64.b64encode(sign)
digest = SHA.new()
digest.update(nonce2_received)
sign = signer.sign(digest)
signature_nonce2_received = base64.b64encode(sign)
 #   f.close()

print "signature_TAdminCurrentPubKey: ",signature_TAdminCurrentPubKey
print "signature_nonce2_received: ",signature_nonce2_received
# and encrypts it with THCurrentPubKey. This message is sent to the target hardware (5)
#with open("THCurrentPubKey.pem") as f:
    #key = f.read()
 #   rsakey = RSA.importKey(THCurrentPubKey)
   # THCurrentPubKey=rsakey
out_file1=open("ciphertext1signature_AdminCurrentPubKey", 'wb')
out_file2 = open("ciphertext2signature_nonce2_received", 'wb')
out_file3 = open("ciphertext3AdminCurrentPubKey", 'wb')
session_key=Random.get_random_bytes(16)   #一个 16 字节的会话密钥
cipher_rsa1 = PKCS1_OAEP.new(RSA.importKey(THCurrentPubKey)) # Encrypt the session key with the public RSA key
cipher_rsa2 = PKCS1_OAEP.new(RSA.importKey(THCurrentPubKey))  # Encrypt the session key with the public RSA key
cipher_rsa3 = PKCS1_OAEP.new(RSA.importKey(THCurrentPubKey))  # Encrypt the session key with the public RSA key
    #cipher_rsa.encrypt(session_key)
out_file1.write(cipher_rsa1.encrypt(session_key))
out_file2.write(cipher_rsa2.encrypt(session_key))
out_file3.write(cipher_rsa3.encrypt(session_key))
cipher_aes1 = AES.new(session_key, AES.MODE_EAX)  # Encrypt the data with the AES session key
ciphertext1, tag1 = cipher_aes1.encrypt_and_digest(signature_TAdminCurrentPubKey)
cipher_aes2 = AES.new(session_key, AES.MODE_EAX)
ciphertext2, tag2 = cipher_aes2.encrypt_and_digest(signature_nonce2_received)
cipher_aes3 = AES.new(session_key, AES.MODE_EAX)
ciphertext3, tag3 = cipher_aes3.encrypt_and_digest(RSA.importKey(AdminCurrentPubKey).exportKey())
    #print(ciphertext1,ciphertext2,ciphertext3)
out_file1.write(cipher_aes1.nonce)
out_file1.write(tag1)
out_file1.write(ciphertext1)
out_file2.write(cipher_aes2.nonce)
out_file2.write(tag2)
out_file2.write(ciphertext2)
out_file3.write(cipher_aes3.nonce)
out_file3.write(tag3)
out_file3.write(ciphertext3)
out_file1.close()
out_file2.close()
out_file3.close()#This message is sent to the target hardware (5).
#f.close()

print("socket data3 sending...")
client.send(open("ciphertext1signature_AdminCurrentPubKey", 'rb').read()) #pair3
client.send(open("ciphertext2signature_nonce2_received", 'rb').read())
client.send(open("ciphertext3AdminCurrentPubKey", 'rb').read())#332,332,431
nonce3=generate_nonce()
client.send(nonce3)
print("socket data3 sent successfully...")

"""Target hardware decrypts the message with THCurrentPrivKey and verifies message authenticity using AdminMasterPubKey (6).
"""

#####################################################################################################
"""
Update package contents
    plain firmware image with nonce attached
    firmware and nonce are hashed and hash is encrypted with AdminCurrentPrivKey. 
    firmware and digital signature encrypted with session key (a randomly generated symmetric encryption key). 
    session key is encrypted with THCurrentPubKey. 
    header containing CRC (Cyclic Redundancy Check), image length etc
"""

fw_name="lks7688.img"

#nonce3=generate_nonce()
#nonce3="1349095738285700"#5de96242a5dcd591fe325aa713c142c2011ea0c69487030526505559fef7e347
h_fw=SHA256.new()
h_nonce3=SHA256.new()
h_nonce3.update(nonce3)
h_fw.update(open(fw_name,'rb').read())
print(h_fw.hexdigest())#4aa6705efd8e0bbe72899411182e2cd1b075ecc1cc0a36a9e052c1fb312f3ba0
print(h_nonce3.hexdigest())#
"""
Hash value of firmware image and nonce is calculated (1) and then encrypted using AdminCurrentPrivKey, 
that way digital signature is created (2). 
"""
signer=Signature_pkcs1_v1_5.new(RSA.importKey(AdminCurrentPrivKey))
digest = SHA.new()
digest.update(h_fw.hexdigest())
sign = signer.sign(digest)
signature_fw = base64.b64encode(sign)
print (signature_fw)
signer=Signature_pkcs1_v1_5.new(RSA.importKey(AdminCurrentPrivKey))
digest = SHA.new()
digest.update(h_nonce3.hexdigest())
sign = signer.sign(digest)
signature_nonce3 = base64.b64encode(sign)
print (signature_nonce3)
"""
Next, session key is generated, -> a randomly generated symmetric encryption key
    - valid only for this communication session
    - symmetric encryption is used because it is much faster while providing comparable security level
Firmware with digital signature is encrypted using session key (3).
Then session key is encrypted with asymmetric cryptographic algorithm using THCurrentPubKey, 
this way digital envelope is created (4). 
"""
session_key_fw=Random.get_random_bytes(16)   #一个 16 字节的会话密钥
with open(fw_name, 'rb') as f:
    fwdata = f.read()
    out_file_fw=open("encrypted_fw.file", 'wb')
    out_file_fwsignature=open("encrypted_fwsignature",'wb')
    out_file_noncesignatue=open("encrypted_noncesignature",'wb')
    recipient_key =RSA.importKey(THCurrentPubKey)
    cipher_rsa1 = PKCS1_OAEP.new(recipient_key)
    cipher_rsa2 = PKCS1_OAEP.new(recipient_key)
    cipher_rsa3 = PKCS1_OAEP.new(recipient_key)
    out_file_fw.write(cipher_rsa1.encrypt(session_key_fw))
    out_file_fwsignature.write(cipher_rsa2.encrypt(session_key_fw))
    out_file_noncesignatue.write(cipher_rsa3.encrypt(session_key_fw))
    cipher_aes_fw = AES.new(session_key_fw, AES.MODE_EAX)
    ciphertext_fw, tag_fw = cipher_aes_fw.encrypt_and_digest(fwdata)
    cipher_aes_fwsignatue=AES.new(session_key_fw, AES.MODE_EAX)
    ciphertext_fwsignatue, tag_fwsignatue = cipher_aes_fwsignatue.encrypt_and_digest(signature_fw)
    cipher_aes_noncesignatue = AES.new(session_key_fw, AES.MODE_EAX)
    ciphertext_noncesignatue, tag_noncesignatue = cipher_aes_noncesignatue.encrypt_and_digest(signature_nonce3)
    out_file_fw.write(cipher_aes_fw.nonce)
    out_file_fw.write(tag_fw)
    out_file_fw.write(ciphertext_fw)
    out_file_fwsignature.write(cipher_aes_fwsignatue.nonce)
    out_file_fwsignature.write(tag_fwsignatue)
    out_file_fwsignature.write(ciphertext_fwsignatue)
    out_file_noncesignatue.write(cipher_aes_noncesignatue.nonce)
    out_file_noncesignatue.write(tag_noncesignatue)
    out_file_noncesignatue.write(ciphertext_noncesignatue)
out_file_fwsignature.close()
out_file_fw.close()
out_file_noncesignatue.close()
f.close()

"""
Update header is added on top, 
    contain information which is not security relevant, i.e. CRC, update package length. 
update package is created and is transferred over the network to the target hardware
"""
fwsize = os.path.getsize(fw_name)
with  open("header_fwlength.txt", 'w') as f:
    print >>f ,fwsize #print(fwsize, file=f)
f.close()


import zipfile
f = zipfile.ZipFile('a.zip','w',zipfile.ZIP_DEFLATED)
f.write("header_fwlength.txt")
f.write("encrypted_fw.file")
f.write("encrypted_fwsignature")
f.write("encrypted_noncesignature")
f.close()

print("socket data4 (fw pack) sending...")
with open('a.zip','rb') as f:
    #按每一段分割文件上传
    for i in f:
        client.send(i)
        #等待接收完成标志
       # data=sk.recv(1024)
        #判断是否真正接收完成
      #  if data == b'success':
         #   break
#给服务端发送结束信号
print("socket data4 (fw pack) sent 100%... waiting to terminate......")
print("you can close and terminate this program manually........ ")
#now_time=time.time()

try:
    while True:
        client.send('quit'.encode())
        if(client.recv(1024)==b'quit'):
            break
#        print time.time() , now_time
#        if(time.time()-now_time>=6):
#            break
except socket.error:
    client.close()
    print("socket closed...")

else:
    print("socket data4 (fw pack) sent successfully...")

client.close()
